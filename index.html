<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="记录...">
<meta property="og:type" content="website">
<meta property="og:title" content="Wuzhao&#39;s blog">
<meta property="og:url" content="http://liwuzhao.github.io/index.html">
<meta property="og:site_name" content="Wuzhao&#39;s blog">
<meta property="og:description" content="记录...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Wuzhao&#39;s blog">
<meta name="twitter:description" content="记录...">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://liwuzhao.github.io/"/>





  <title>Wuzhao's blog</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Wuzhao's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://liwuzhao.github.io/2019/01/05/JVM笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wuzhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/wuzhao1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wuzhao's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/JVM笔记/" itemprop="url">Iterator</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T10:26:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>摘抄《深入理解java虚拟机》学习笔记，方便自己翻阅</p>
</blockquote>
<p>###内存分区</p>
<p><img src="https://images2015.cnblogs.com/blog/820406/201603/820406-20160326200119386-756216654.png" alt=""></p>
<p><strong>虚拟机栈</strong>：每个线程有一个私有的栈，随着线程的创建而创建。栈里面存着的是一种叫“栈帧”的东西，每个方法会创建一个栈帧，栈帧中存放了<strong>局部变量表</strong>（基本数据类型和对象引用）、操作数栈、方法出口等信息</p>
<p><strong>本地方法栈</strong>：这部分主要与虚拟机用到的 Native 方法相关，一般情况下， Java 应用程序员并不需要关心这部分的内容。</p>
<p>PC 寄存器，也叫<strong>程序计数器</strong>。JVM支持多个线程同时运行，每个线程都有自己的程序计数器。倘若当前执行的是 JVM 的方法，则该寄存器中保存当前执行指令的地址；倘若执行的是native 方法，则PC寄存器中为空。</p>
<p><strong>堆内存</strong>是 JVM 所有线程共享的部分，在虚拟机启动的时候就已经创建。几乎所有的对象实例都在堆上分配。可细分为<a href="https://blog.csdn.net/sted_zxz/article/details/72476673" target="_blank" rel="external">年轻代、老年代</a>。这部分空间可通过 GC 进行回收。当申请不到空间时会抛出 OutOfMemoryError。</p>
<p><strong>方法区</strong>也是所有线程共享。主要用于存储类的信息、常量池、方法数据、方法代码等。方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。 关于方法区内存溢出的问题会在下文中详细探讨。</p>
<h3 id="2-GC"><a href="#2-GC" class="headerlink" title="2. GC"></a>2. GC</h3><p>####2.1 如何判定一个对象已死：</p>
<p>根搜索法：</p>
<p>它把内存中的每一个对象看成一个节点，并定义了一些对象作为根节点（<strong>GC Roots</strong>）。如果一个对象中有对另一个对象中的引用，那么就认为第一个对象有一条指向第二个对象的边。<strong>JVM</strong>会起一个线程从所有的<strong>GC Roots</strong>开始往下遍历，当遍历完之后如果发现有一些对象不可到达，那么就认为这些对象已经没有用了，需要被回收。</p>
<p>可以作为<strong>GC Roots</strong>的对象：</p>
<ul>
<li><p>Java 虚拟机栈中引用的对象</p>
<p>首先第一种是虚拟机栈中的引用的对象，我们在程序中正常创建一个对象，对象会在堆上开辟一块空间，同时会将这块空间的地址作为引用保存到虚拟机栈中，如果对象生命周期结束了，那么引用就会从虚拟机栈中出栈，因此如果在虚拟机栈中有引用，就说明这个对象还是有用的，这种情况是最常见的。</p>
</li>
<li><p>方法区中的静态成员</p>
<p>第二种是我们在类中定义了全局的静态的对象，也就是使用了<strong>static</strong> 关键字，由于虚拟机栈是线程私有的，所以这种对象的引用会保存在共有的方法区中，显然将方法区中的静态引用作为<strong>GC Roots</strong>是必须的。</p>
</li>
<li><p>方法区中的常量引用对象</p>
<p>第三种便是常量引用，就是使用了<strong>static final</strong> 关键字，由于这种引用初始化之后不会修改，所以方法区常量池里的引用的对象也应该作为<strong>GC Roots</strong>。</p>
</li>
<li><p>本地方法区中的 JNI（Native 方法）引用的对象</p>
<p>最后一种是在使用 <strong>JNI</strong> 技术时，有时候单纯的 <strong>Java</strong> 代码并不能满足我们的需求，我们可能需要在 <strong>Java</strong> 中调用 <strong>C</strong>或 <strong>C++</strong> 的代码，因此会使用 <strong>native</strong>方法，JVM内存中专门有一块本地方法栈，用来保存这些对象的引用，所以本地方法栈中引用的对象也会被作为<strong>GC Roots</strong>。</p>
</li>
</ul>
<h4 id="2-2-垃圾回收算法"><a href="#2-2-垃圾回收算法" class="headerlink" title="2.2 垃圾回收算法"></a>2.2 垃圾回收算法</h4><p>年轻代：每次GC都有大量的对象死去，只有少量存活，采取<strong>复制算法</strong>，将内存分为一块较大的Eden空间和两块较小的Survivor空间，将Eden和Survivor存活的对象拷贝到另一个Survivor空间上，然后清理Eden和第一块Survivor。</p>
<p>老年代：对象成活率高，使用<strong>标记-清理</strong>或<strong>标记-整理</strong>的算法来回收，前者是标记所有要回收的对象，然后进行清理，会产生大量不连续的内存碎片。后者是将可回收的对象进行整理，将活着的对象向一端移动，然后清理所有界外内存。</p>
<h4 id="2-3-对象分配"><a href="#2-3-对象分配" class="headerlink" title="2.3 对象分配"></a>2.3 对象分配</h4><ul>
<li><p>对象优先在Eden分配，如果Eden空间不够，将发起一次Minor GC，如果要转移的对象无法全部转入到第二块Survivor区，那么会通过分配担保机制将这些对象提前转移到老年代。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">byte</span> [] a1,a2,a3,a4;</div><div class="line">  a1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</div><div class="line">  a2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</div><div class="line">  a3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</div><div class="line">  a4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
<p>​通过-Xms20M、-Xmx20M和-Xmn10m，限制java堆大小为20M，其中新生代10M，老年代10M。</p>
<p>​-XX:SurvivorRatio=8 决定了新生代Eden区和一个Survivor区的空间比为8：1。所以Eden区有8M，两个Survivor区各有1M。</p>
<p>​当分配a4时，Eden空间不足，触发一次Minor GC，三个2M的对象无法放入第二个Survivor区，所以提前转入老年代。所以结果是 Eden 区占用4M（a4），老年代占用6M（a1，a2，a3）</p>
</li>
</ul>
<ul>
<li>大对象直接进入老年代，典型的大对象有字符串及数组。虚拟机提供一个参数 -XX:PretenureSizeThreshold，大于这个参数的对象将在老年代进行分配，默认是0，意思是都优先在Eden区进行分配。设置这个参数是避免在Eden区和两个Survivor区发生大量的内存拷贝。</li>
<li>长期存活的对象进入老年代。虚拟机给每个对象定义了一个age计数器，如果对象在Eden区出声并经过第一次Minor GC后仍存活，并且能被Survivor容纳的话，age就加1。对象在Survivor区每经过一次Minor GC，年龄就加1。当年龄大于一个值（默认是15，可以通过-XX:MaxTenuringThreshold来设置）时，将其晋升到老年代中。</li>
<li>动态年龄判定。如果Survivor空间中相同年龄所有对象的大小总和大于Survivor空间的一半，大于或等于这个年龄的对象直接进入老年代，无需等到MaxTenuringThreshold要求的年龄。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://liwuzhao.github.io/2019/01/05/一致性哈希算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wuzhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/wuzhao1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wuzhao's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/一致性哈希算法/" itemprop="url">Iterator</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T10:26:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>一些简单的学习笔记记录，摘抄别人的blog，方便自己翻阅</p>
</blockquote>
<p>假如做了redis集群，有4台服务器，对于一条数据要存储在哪一台服务器上，假如我们用取模的方式计算。<code>hash(data) % 4</code>，假如<code>hash(data) % 4 = 2</code>，即在第二台服务器上。但是当我们添加一台服务器时，就变成了<code>hash(data) % 5</code>，显然结果不会是2，即所有的缓存数据位置都要发生变化。</p>
<p>一致性hash算法也是用取模的方式，但是它是对对2^32取模，将空间画成一个圆环。每台服务器根据一定规则进行hash，确定服务器在圆环上的地址。然后将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。</p>
<p><img src="https://pic4.zhimg.com/80/v2-4fab60735dfae0bf511709e9d337789b_hd.jpg" alt="img"></p>
<p>这样的话，假如 Node C 宕机了，只需要将 Object C 进行重定位，而A B D是不会受到影响的。假如增加一台服务器同理，受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。</p>
<p>假如服务器数量较少，会容易发生数据倾斜，即大部分数据都落在同一个服务器上。为了解决这种数据倾斜问题，一致性Hash算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器IP或主机名的后面增加编号来实现。比如对服务器A，计算出Node A #1 , Node A#2，这几个虚拟节点的数据都落在服务器A上。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://liwuzhao.github.io/2019/01/05/shiro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wuzhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/wuzhao1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wuzhao's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/shiro/" itemprop="url">Iterator</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T10:26:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>一些简单的学习笔记记录，摘抄别人的blog，方便自己翻阅,更新中</p>
</blockquote>
<p>Subject 用户主体</p>
<p>SecurityManager 用户认证、用户授权的处理</p>
<p>Realm 配合 SecurityManager进行验证，SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法。</p>
<p>自定义 Realm，继承 AuthorizingRealm 类，实现两个方法：</p>
<ul>
<li>doGetAuthorizationInfo，用于授权，查出用户权限，返回</li>
</ul>
<ul>
<li>doGetAuthenticationInfo，用于验证（登录），验证传入的账号密码是否正确，然后返回</li>
</ul>
<p>然后注入到 SecurityManager 中</p>
<h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h4><p>filter 过滤</p>
<p>注解方式，声明某个方法只有特定的角色或者权限才能方法</p>
<p>内置过滤器</p>
<p>自定义filter</p>
<h4 id="Session管理"><a href="#Session管理" class="headerlink" title="Session管理"></a>Session管理</h4><p>SessionDao，session 的增删改查操作，可以重写，自定义把 session 存储在redis里（插件 shiro-redis)</p>
<p>SessionManger，可以应用自定义的 SessionDao，也可以重写 SessionManger 获取 session 和 sessionId 的方法，注入到 SecurityManager 中。</p>
<h4 id="缓存管理"><a href="#缓存管理" class="headerlink" title="缓存管理"></a>缓存管理</h4><p>cache 缓存权限信息、角色信息</p>
<p>Cache，缓存的增删操作，可以继承 Cache<k,v> 来自定义Cache，用redis存储。</k,v></p>
<p>CacheManger，可自定义，实现 CacheManger 接口，实现 getCache 返回自定义的 Cache 即可，注入到 SecurityManager 中</p>
<h3 id="记住我，setRememberMe"><a href="#记住我，setRememberMe" class="headerlink" title="记住我，setRememberMe"></a>记住我，setRememberMe</h3><p>SimpleCookie 对象</p>
<p>CookieRememberMeManger，注入到 SecurityManager 中</p>
<p>UsernamePasswordToken 可以设置 rememberMe 变量（boolean）</p>
<h4 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h4><p>自定义MySessionManager类继承DefaultWebSessionManager类，可以重写getSessionId方法，从request 中取出sessionId</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySessionManager</span>  <span class="keyword">extends</span> <span class="title">DefaultWebSessionManager</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTHORIZATION = <span class="string">"Authorization"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REFERENCED_SESSION_ID_SOURCE = <span class="string">"Stateless request"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySessionManager</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Serializable <span class="title">getSessionId</span><span class="params">(ServletRequest request, ServletResponse response)</span> </span>&#123;</div><div class="line">        String id = WebUtils.toHttp(request).getHeader(AUTHORIZATION);</div><div class="line">        <span class="comment">//如果请求头中有 Authorization 则其值为sessionId</span></div><div class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(id)) &#123;</div><div class="line">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE, REFERENCED_SESSION_ID_SOURCE);</div><div class="line">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, id);</div><div class="line">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE);</div><div class="line">            <span class="keyword">return</span> id;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//否则按默认规则从cookie取sessionId</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.getSessionId(request, response);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>登录api中返回登录状态，前端通过该状态决定是否成功</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Subject subject = SecurityUtils.getSubject();</div><div class="line"><span class="comment">// 构造一个token</span></div><div class="line">UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(user.getUsername(), user.getPassword());</div><div class="line"><span class="comment">// 调subject的登录方法</span></div><div class="line">subject.login(token);</div><div class="line"><span class="comment">// 成功的话可以返回 sessionId 给前端</span></div><div class="line"><span class="keyword">return</span> subject.getSession().getId());</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://liwuzhao.github.io/2018/12/03/MySQL一致性视图/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wuzhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/wuzhao1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wuzhao's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/03/MySQL一致性视图/" itemprop="url">MySQL一致性视图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-03T00:00:00+08:00">
                2018-12-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>极客时间《MySQL实战》的一道思考题，关于更新失效的一些简单笔记。</p>
</blockquote>
<h3 id="一致性视图"><a href="#一致性视图" class="headerlink" title="一致性视图"></a>一致性视图</h3><p>MVCC ：每次事务更新时，都会生成一个新的数组版本，把 transaction_id 赋值给这行数据，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</p>
<p><strong>可重复读</strong>下，当事务开启的时候，构造了一个数组，保存了所有<strong>启动了但还没提交</strong>的事务 ID，也就是「活跃」的事务。数组里的事务 ID 最小值为低水位，当前系统已创建的事务 ID 最大值 + 1为最高位。</p>
<p>这个数组和高水位，组成了事务的一致性视图。</p>
<p>当事务访问数据时，row trx_id 大于高水位，或者在活跃事务数组内的，都不可见，会通过历史记录，找到最近可见的那个 row trx_id。</p>
<p>注意，在可重读的隔离级别下，当事务中第一个查询语句执行时，快照才会被建立。</p>
<p>以前理解的是，事务会读到  row trx_id 比当前事务版本小的数据。假如一个 id 98的事务，更新了数据，那么row trx_id 就为98，那么在 id 99的事务中不就会读到这个数据，违反一致性了吗？看了专栏后了解了还会有一个活跃事务的存在，在 id 99的事务的一致性视图中，存在 id 98的活跃事务，所以这行数据也是不可见的。</p>
<p>实践一下：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fxtp031x7cj31jy0hugud.jpg" alt="WeChat158e7a9ca1e2e20e065fc69e872adf74"></p>
<p>如图，虽然事务 B 比 事务 A先开启，但事务 B 的更新对事务 A 仍然不可见。 </p>
<p>也就是说，事务 A 开始时，A 的一致性视图的活跃事务中包含了 B，即使 B 事务的更新提交了，对 A 仍是不可见的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://liwuzhao.github.io/2018/11/28/spring springmvc 配置使失误失效/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wuzhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/wuzhao1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wuzhao's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/28/spring springmvc 配置使失误失效/" itemprop="url">spring springmvc 配置使事务失效</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-28T00:00:00+08:00">
                2018-11-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>一些简单的学习笔记记录，摘抄别人的blog，方便自己翻阅</p>
</blockquote>
<p>在web-xml中</p>
<p>先加载父容器 application-context</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;context-param&gt;</div><div class="line">  &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</div><div class="line">  &lt;param-value&gt;classpath:spring/application-config.xml&lt;/param-value&gt;</div><div class="line">&lt;/context-param&gt;</div></pre></td></tr></table></figure>
<p>再加载子容器dispatcherServlet，里面只加载controller</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;servlet&gt;</div><div class="line">  &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;</div><div class="line">  &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</div><div class="line">  &lt;init-param&gt;</div><div class="line">    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</div><div class="line">    &lt;param-value&gt;/WEB-INF/mvc-config.xml&lt;/param-value&gt;</div><div class="line">  &lt;/init-param&gt;</div><div class="line">  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</div><div class="line">  &lt;async-supported&gt;true&lt;/async-supported&gt;</div><div class="line">&lt;/servlet&gt;</div></pre></td></tr></table></figure>
<p>Spring和springmvc和作为两个独立的容器，会把扫描到的注解对象分别放到两个不同的容器中，</p>
<p>Springmvc容器是spring容器的一部分，他们访问对象的范围如下所示：</p>
<p>①：springmvc子容器可以访问spring父容器中的对象</p>
<p>②：spring父容器不能访问springmvc子容器中的对象</p>
<p>1.如果全部把注解放到spring.xml中配置：<br>当一旦采用这种方式之后，spring会将扫描的对象都会存放到spring的容器，而不会放到springmvc子容器中，当访问项目的时候，springmvc找不到处理器映射器，和其对应的Controller，进而报404错误！</p>
<p>2.不用spring容器，把注解全部放到springmvc中扫描：<br>是可以的，在这个里面可以同时扫描Controller层、service层、dao层的注解，但是，<strong>子容器Controller进行扫描装配时装配了@Service注解的实例，而该实例理应由父容器进行初始化以保证事务的增强处理（因为事务管理器是配置在spring容器中的），所以此时得到的将是原样的Service（没有经过事务加强处理，故而没有事务处理能力</strong>。同理，springmvc中配置controller后也不能将事务配置在controller层，因为因为事务管理器是配置在spring容器中的，如果将事务配置在Controller层的话，spring容器就访问不了springmvc子容器，进而无法访问到事务对象。进而导致事务失效。</p>
<h3 id="事务不生效"><a href="#事务不生效" class="headerlink" title="事务不生效"></a>事务不生效</h3><p>一般的做法是父容器（spring）扫描时，排除掉 controller，留给子容器加载</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;context:component-scan base-package="com"&gt;</div><div class="line">		&lt;!--声明除了@Controller之外的bean --&gt;</div><div class="line">	&lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller" /&gt;</div><div class="line">&lt;/context:component-scan&gt;</div></pre></td></tr></table></figure>
<p>子容器（spring mvc）则负责扫描 controller</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;context:component-scan base-package="com"&gt;</div><div class="line">&lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller" /&gt;</div><div class="line">&lt;/context:component-scan&gt;</div></pre></td></tr></table></figure>
<p>但是发现这种配置下，在service实现层的 @Transactional 事务不生效</p>
<p>因为在 context:component-scan 时，使用了 <code>use-default-filters=&quot;true&quot;</code> （默认值为true） 会扫描 @Component 的所有子类，即包括 @Service，但是事务配置在父容器中进行装配的，所以重新扫描得到的将是原样的Service，导致事务失效。</p>
<p>可以设置成 use-default-filters = false</p>
<p>或者在子容器中，exclude 掉 service</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;context:exclude-filter type=<span class="string">"annotation"</span> expression=<span class="string">"org.springframework.stereotype.Service"</span> /&gt;</div></pre></td></tr></table></figure>
<p><a href="http://www.cnblogs.com/hafiz/p/5875770.html" target="_blank" rel="external">参考</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://liwuzhao.github.io/2018/11/06/Executor框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wuzhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/wuzhao1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wuzhao's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/06/Executor框架/" itemprop="url">Executor框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-06T22:51:40+08:00">
                2018-11-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>一些简单的学习笔记记录，摘抄别人的blog，方便自己翻阅</p>
</blockquote>
<h3 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h3><p>线程池</p>
<p>任务分两类：一类是实现了 Runnable 接口的类，一类是实现了 Callable 接口的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ExecutorService executorService = Executors.newCachedThreadPool();</div><div class="line"><span class="comment">// execute调用 runable</span></div><div class="line">executorService.execute(<span class="keyword">new</span> TestRunnable());   </div><div class="line"><span class="comment">// submit调用 callable(有返回值)</span></div></pre></td></tr></table></figure>
<p>返回值：当我们把<strong>Runnable接口</strong>或<strong>Callable接口</strong>的实现类提交（调用submit方法）给<strong>ThreadPoolExecutor</strong>或<strong>ScheduledThreadPoolExecutor</strong>时，会返回一个<strong>FutureTask对象</strong>。</p>
<ul>
<li><strong>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li>
<li><strong>submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功</strong>，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>
</ul>
<h4 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h4><p>线程池的运行状态. 线程池一共有五种状态, 分别是:</p>
<ol>
<li><p><strong>RUNNING </strong>：能接受新提交的任务，并且也能处理阻塞队列中的任务；</p>
</li>
<li><p><strong>SHUTDOWN</strong>：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用 shutdown()方法会使线程池进入到该状态。（finalize() 方法在执行过程中也会调用shutdown()方法进入该状态）；</p>
</li>
<li><p><strong>STOP</strong>：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态；</p>
</li>
<li><p><strong>TIDYING</strong>：如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态。</p>
</li>
<li><p>TERMINATED</p>
<p>：在terminated() 方法执行完后进入该状态，默认terminated()方法中什么也没有做。</p>
<p>进入TERMINATED的条件如下：</p>
<ul>
<li>线程池不是RUNNING状态；</li>
<li>线程池状态不是TIDYING状态或TERMINATED状态；</li>
<li>如果线程池状态是SHUTDOWN并且workerQueue为空；</li>
<li>workerCount为0；</li>
<li>设置TIDYING状态成功。</li>
</ul>
</li>
</ol>
<h4 id="构造参数中的几个参数"><a href="#构造参数中的几个参数" class="headerlink" title="构造参数中的几个参数"></a>构造参数中的几个参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span> <span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span>	keepAliveTime, TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue)</span></span></div></pre></td></tr></table></figure>
<ul>
<li><p><strong>corePoolSize</strong>：核心线程数量，当有新任务在execute()方法提交时，会执行以下判断：</p>
<ol>
<li>如果运行的线程少于 corePoolSize，则创建新线程来处理任务，即使线程池中的其他线程是空闲的；</li>
<li>如果线程池中的线程数量大于等于 corePoolSize 且小于 maximumPoolSize，则只有当workQueue满时才创建新的线程去处理任务；</li>
<li>如果设置的corePoolSize 和 maximumPoolSize相同，则创建的线程池的大小是固定的，这时如果有新任务提交，若workQueue未满，则将请求放入workQueue中，等待有空闲的线程去从workQueue中取任务并处理；</li>
<li>如果运行的线程数量大于等于maximumPoolSize，这时如果workQueue已经满了，则通过handler所指定的策略来处理任务；</li>
</ol>
<p>所以，任务提交时，判断的顺序为 corePoolSize –&gt; workQueue –&gt; maximumPoolSize。</p>
</li>
<li><p>maximumPoolSize：池中允许的最大线程数。</p>
</li>
<li><p>keepAliveTime：线程池中的空闲线程所能持续的最长时间。</p>
</li>
<li><p>unit：持续时间的单位。</p>
</li>
<li><p>等待队列，当任务提交时，如果线程池中的线程数量大于等于corePoolSize的时候，把该任务封装成一个Worker对象放入等待队列；</p>
</li>
<li><p>workQueue</p>
<p>：保存等待执行的任务的阻塞队列，当提交一个新的任务到线程池以后, 线程池会根据当前线程池中正在运行着的线程的数量来决定对该任务的处理方式，主要有以下几种处理方式:</p>
<ol>
<li><p><strong>直接切换</strong>：这种方式常用的队列是SynchronousQueue（待研究）</p>
</li>
<li><p><strong>使用无界队列</strong>：一般使用基于链表的阻塞队列LinkedBlockingQueue。如果使用这种方式，那么线程池中能够创建的最大线程数就是corePoolSize，而maximumPoolSize就不会起作用了。当线程池中所有的核心线程都是RUNNING状态时，这时一个新的任务提交就会放入等待队列中。</p>
</li>
<li><p>使用有界队列</p>
<p>：一般使用ArrayBlockingQueue。使用该方式可以将线程池的最大线程数量限制为maximumPoolSize，这样能够降低资源的消耗，但同时这种方式也使得线程池对线程的调度变得更困难，因为线程池和队列的容量都是有限的值，所以要想使线程池处理任务的吞吐率达到一个相对合理的范围，又想使线程调度相对简单，并且还要尽可能的降低线程池对资源的消耗，就需要合理的设置这两个数量。</p>
<ul>
<li>如果要想降低系统资源的消耗（包括CPU的使用率，操作系统资源的消耗，上下文环境切换的开销等）, 可以设置较大的队列容量和较小的线程池容量, 但这样也会降低线程处理任务的吞吐量。</li>
<li>如果提交的任务经常发生阻塞，那么可以考虑通过调用 setMaximumPoolSize() 方法来重新设定线程池的容量。</li>
<li>如果队列的容量设置的较小，通常需要将线程池的容量设置大一点，这样CPU的使用率会相对的高一些。但如果线程池的容量设置的过大，则在提交的任务数量太多的情况下，并发量会增加，那么线程之间的调度就是一个要考虑的问题，因为这样反而有可能降低处理任务的吞吐量。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ul>
<li><strong>FixedThreadPool</strong> ，固定线程数</li>
<li><strong>SingleThreadExecutor</strong>，单个线程</li>
<li><strong>CachedThreadPool</strong>，根据需要创建新线程的线程池</li>
</ul>
<h4 id="shutdown（）VS-shutdownNow（）"><a href="#shutdown（）VS-shutdownNow（）" class="headerlink" title="shutdown（）VS shutdownNow（）"></a>shutdown（）VS shutdownNow（）</h4><p>shutdown（）方法表明关闭已在Executor上调用，因此不会再向DelayedPool添加任何其他任务（由ScheduledThreadPoolExecutor类在内部使用）。 但是，已经在队列中提交的任务将被允许完成。 另一方面，shutdownNow（）方法试图终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的List。</p>
<h4 id="isTerminated-Vs-isShutdown"><a href="#isTerminated-Vs-isShutdown" class="headerlink" title="isTerminated() Vs isShutdown()"></a>isTerminated() Vs isShutdown()</h4><p>isShutdown（）表示执行程序正在关闭，但并非所有任务都已完成执行。 另一方面，isShutdown（）表示所有线程都已完成执行</p>
<p>isTerminated当调用shutdown()方法后，并且所有提交的任务完成后返回为true;</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://liwuzhao.github.io/2018/11/06/CAS机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wuzhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/wuzhao1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wuzhao's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/06/CAS机制/" itemprop="url">CAS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-06T22:51:17+08:00">
                2018-11-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>一些简单的学习笔记记录，摘抄别人的blog，方便自己翻阅</p>
</blockquote>
<p>乐观锁机制，假设没有并发，如果出现冲突，再做处理</p>
<h4 id="CAS中有三个核心参数："><a href="#CAS中有三个核心参数：" class="headerlink" title="CAS中有三个核心参数："></a>CAS中有三个核心参数：</h4><p>1.主内存中存放的V值，所有线程共享。</p>
<p>2.线程上次从内存中读取的V值A存放在线程的帧栈中，每个线程私有。</p>
<p>3.需要写入内存中并改写V值的B值。也就是线程对A值操作后放入到主存V中。</p>
<h4 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h4><p>Sway And Compare</p>
<p>假设主存 V = 1，有两条线程要做对 V 进行自增的操作</p>
<ul>
<li><p>假设Thread1，Thread 2先读取V值赋给A，并且对A进行加1，得到B=2。</p>
</li>
<li><p>Thread 2 先提交，提交前  比较 A == V，正确，直接写入主存</p>
</li>
<li><p>Thread 1再做提交，提交前  比较 A == V，因为此时 V = 2，所以为false，返回 V 的值给Thread 1的A，</p>
<p>然后对 A 再次进行 +1，得到 B。此时  A = 2， B = 3，比较 A == V 正确，将B提交，更新主存。</p>
</li>
<li><p>V 变为了3</p>
</li>
</ul>
<h4 id="CAS的缺点："><a href="#CAS的缺点：" class="headerlink" title="CAS的缺点："></a>CAS的缺点：</h4><ul>
<li>CPU开销较大</li>
</ul>
<p>在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</p>
<ul>
<li>不能保证代码块的原子性</li>
</ul>
<p>CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。</p>
<ul>
<li>ABA问题</li>
</ul>
<p>如果一开始位置V得到的旧值是A，当进行赋值操作时再次读取发现仍然是A，并不能说明变量没有被其它线程改变过。有可能是其它线程将变量改为了B，后来又改回了A。</p>
<p>可以通过版本号来解决，即比较V的时，要求版本号也一致</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://liwuzhao.github.io/2018/10/22/LinkedHashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wuzhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/wuzhao1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wuzhao's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/22/LinkedHashMap/" itemprop="url">LinkedHashMap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-22T22:46:05+08:00">
                2018-10-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>一些简单的学习笔记记录，摘抄别人的blog，方便自己翻阅</p>
</blockquote>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>LinkedHashMap是将所有桶中的节点串联成一个双向链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//accessOrder为true，每次get或put，都将该节点移到链表尾(LRU)</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></div><div class="line">                     <span class="keyword">float</span> loadFactor,</div><div class="line">                     <span class="keyword">boolean</span> accessOrder) &#123;</div><div class="line">  <span class="keyword">super</span>(initialCapacity, loadFactor);</div><div class="line">  <span class="keyword">this</span>.accessOrder = accessOrder;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15166377647704.jpg" alt="img"></p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>Map 类型的集合类是通过 put(K,V) 方法插入键值对，LinkedHashMap 本身并没有覆写父类的 put 方法，而是直接使用了父类的实现。但在 HashMap 中，put 方法插入的是 HashMap 内部类 Node 类型的节点，该类型的节点并不具备与 LinkedHashMap 内部类 Entry 及其子类型节点组成链表的能力。</p>
<p>LinkedHashMap对newNode（新建Entry）方法和linkNodeLast（将新的节点链接到链表尾部）进行了重写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LinkedHashMap 中覆写</span></div><div class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</div><div class="line">    <span class="comment">// 将 Entry 接在双向链表的尾部</span></div><div class="line">    linkNodeLast(p);</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// LinkedHashMap 中实现</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</div><div class="line">    tail = p;</div><div class="line">    <span class="comment">// last 为 null，表明链表还未建立</span></div><div class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</div><div class="line">        head = p;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 将新节点 p 接在链表尾部</span></div><div class="line">        p.before = last;</div><div class="line">        last.after = p;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>调用afterNodeRemoval，删除后维护双链表</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://liwuzhao.github.io/2018/10/22/Iterator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wuzhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/wuzhao1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wuzhao's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/22/Iterator/" itemprop="url">Iterator</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-22T22:46:05+08:00">
                2018-10-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>一些简单的学习笔记记录，摘抄别人的blog，方便自己翻阅</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 接口Iterator</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</div><div class="line">　　<span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</div><div class="line">　　<span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</div><div class="line">　　<span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用 Iterator 接口，不必知道集合的内部结果,集合的内部结构、状态由Iterator来维持，通过统一的方法hasNext()、next()来判断、获取下一个元素。</p>
<p><strong>ArrayList</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ArrayList 中一个内部类 Itr 实现了 Iterator接口</span></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">	<span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></div><div class="line">	<span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></div><div class="line">	<span class="keyword">int</span> expectedModCount = modCount; <span class="comment">// List中有一个 modCount，记录集合被修改的次数。</span></div><div class="line">		...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 而ArrayList的iterator()方法实现：</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">            checkForComodification(); <span class="comment">// 检查集合是否被修改</span></div><div class="line">            <span class="keyword">int</span> i = cursor;    <span class="comment">//记录索引位置</span></div><div class="line">            <span class="keyword">if</span> (i &gt;= size)    <span class="comment">//如果获取元素大于集合元素个数，则抛出异常</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">            Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</div><div class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">            cursor = i + <span class="number">1</span>;      <span class="comment">//cursor + 1</span></div><div class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];  <span class="comment">//lastRet + 1 且返回cursor处元素</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 检查集合是否被修改</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为 fail-fast 原则，在迭代器中修改了集合是会抛出异常的，所以应该调用iterator 的 remove 方法，来安全地删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">            checkForComodification();</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                ArrayList.<span class="keyword">this</span>.remove(lastRet);</div><div class="line">                cursor = lastRet;</div><div class="line">                lastRet = -<span class="number">1</span>;</div><div class="line">                expectedModCount = modCount; <span class="comment">// 修改expectedModCount</span></div><div class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">            &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://liwuzhao.github.io/2018/10/22/HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wuzhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/wuzhao1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wuzhao's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/22/HashMap/" itemprop="url">HashMap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-22T22:46:05+08:00">
                2018-10-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><blockquote>
<p>一些简单的学习笔记记录，摘抄别人的blog，方便自己翻阅</p>
</blockquote>
<p>计算key的hashcode，得出存储的数组下标，如果该数组已经有值，则<strong>就添加到同一hash值的元素的后面</strong>，形成链表。当链表长度超过8时转为红黑树。</p>
<p>key-value的键值对，用数组+链表实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">transient</span> Node&lt;k,v&gt;[] table;<span class="comment">//存储（位桶）的数组&lt;/k,v&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Node是单向链表，它实现了Map.Entry接口</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">k</span>,<span class="title">v</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">k</span>,<span class="title">v</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</div><div class="line">    <span class="keyword">final</span> K key;</div><div class="line">    V value;</div><div class="line">    Node&lt;k,v&gt; next;</div><div class="line">    <span class="comment">//构造函数Hash值 键 值 下一个节点</span></div><div class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;k,v&gt; next) &#123;</div><div class="line">        <span class="keyword">this</span>.hash = hash;</div><div class="line">        <span class="keyword">this</span>.key = key;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">        <span class="keyword">this</span>.next = next;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + = + value; &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</div><div class="line">        V oldValue = value;</div><div class="line">        value = newValue;</div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//判断两个node是否相等,若key和value都相等，返回true。可以与自身比较为true</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</div><div class="line">            Map.Entry&lt;!--?,?--&gt; e = (Map.Entry&lt;!--?,?--&gt;)o;</div><div class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</div><div class="line">                Objects.equals(value, e.getValue()))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 红黑树</span></div><div class="line"><span class="comment">//红黑树</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">k</span>,<span class="title">v</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">k</span>,<span class="title">v</span>&gt; </span>&#123;</div><div class="line">    TreeNode&lt;k,v&gt; parent;  <span class="comment">// 父节点</span></div><div class="line">    TreeNode&lt;k,v&gt; left; <span class="comment">//左子树</span></div><div class="line">    TreeNode&lt;k,v&gt; right;<span class="comment">//右子树</span></div><div class="line">    TreeNode&lt;k,v&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></div><div class="line">    <span class="keyword">boolean</span> red;    <span class="comment">//颜色属性</span></div><div class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;k,v&gt; next) &#123;</div><div class="line">        <span class="keyword">super</span>(hash, key, val, next);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">//返回当前节点的根节点</span></div><div class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;k,v&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (TreeNode&lt;k,v&gt; r = <span class="keyword">this</span>, p;;) &#123;</div><div class="line">            <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> r;</div><div class="line">            r = p;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="加载因子（默认为0-75）"><a href="#加载因子（默认为0-75）" class="headerlink" title="加载因子（默认为0.75）"></a>加载因子（默认为0.75）</h4><p>当数组存储的个数/ 数组长度 &gt; 加载因子，进行扩容。</p>
<p>因为如果填充比很大，说明利用的空间很多，如果一直不进行扩容的话，链表就会越来越长，这样查找的效率很低，因为链表的长度很大（当然最新版本使用了红黑树后会改进很多），扩容之后，将原来链表数组的每一个链表分成奇偶两个子链表分别挂在新链表数组的散列位置，这样就减少了每个链表的长度，增加查找效率</p>
<h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><ul>
<li>判断键值对数组tab[]是否为空或为null，否则以默认大小resize()；</li>
<li>根据键值key计算hash值得到插入的数组索引i，如果tab[i]==null，直接新建节点添加，否则转入3</li>
<li>判断当前数组中处理hash冲突的方式为链表还是红黑树(check第一个节点类型即可),分别处理</li>
</ul>
<h4 id="取"><a href="#取" class="headerlink" title="取"></a>取</h4><p>get(key)方法时获取key的hash值，计算hash&amp;(n-1)得到在链表数组中的位置first=tab[hash&amp;(n-1)],先判断first的key是否与参数key相等，不等就遍历后面的链表找到相同的key值返回对应的Value值即可</p>
<h4 id="扩容-resize"><a href="#扩容-resize" class="headerlink" title="扩容 resize"></a>扩容 resize</h4><p>构造hash表时，如果不指明初始大小，默认大小为16（即Node数组大小16），如果Node[]数组中的元素达到（填充比*Node.length）重新调整HashMap大小 变为原来2倍大小,扩容很耗时</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/wuzhao1.jpg"
               alt="wuzhao" />
          <p class="site-author-name" itemprop="name">wuzhao</p>
           
              <p class="site-description motion-element" itemprop="description">记录...</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">131</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wuzhao</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
